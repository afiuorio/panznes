use crate::nes::ppu::palette::NES_PALETTE;
use crate::nes::system_bus::{PPUCTRL, PPUMASK, PPUSTATUS};
use crate::nes::Nes;
use std::ops::Mul;

mod memory;
mod palette;

impl<'a> Nes<'a> {
    fn get_active_pattern_table(&mut self, bit: PPUCTRL) -> u16 {
        if self.ppuctrl.contains(bit) {
            0x1000
        } else {
            0x0000
        }
    }

    fn get_tile_pixel_from_planes(
        tile_first_plane: u8,
        tile_second_plane: u8,
        which_pixel: u8,
    ) -> u8 {
        (tile_first_plane >> (7 - which_pixel) & 0x1)
            | ((tile_second_plane >> (7 - which_pixel) & 0x1) << 1)
    }

    fn write_background(&mut self, current_scanline: u16) {
        //We need to write the background pixels for this scanline
        //Each tile in the nametable is 8x8 and a row has 32 tiles,
        //So the tiles for this scanline starts at current_scanline / 8 * 32
        let nametable_row = (current_scanline >> 0x3) << 5;
        //Which of the 8 rows in the tile we are rendering?
        let current_tile_row = current_scanline & 0x7;

        let pattern_table: u16 = self.get_active_pattern_table(PPUCTRL::BACKGROUND_PATTERN_TABLE);

        for i in 0..=31 {
            let nametable_index = nametable_row.wrapping_add(i);
            //TODO the starting point depends on scrolling registers
            let nametable: u16 = 0x2000;
            let tile_index = self.read_ppu_byte(nametable.wrapping_add(nametable_index));
            //Each tile is 16 bytes long, so the address of the tile is base + (index *16)
            let tile_address = pattern_table.wrapping_add(u16::from(tile_index) << 4);

            // Each pixel in a tile is 2 bit, however these are not consecutive bits. The 16 bytes
            // of the tiles are divided by 2 8-byte "planes". Each byte in a plane represent one of
            // the 8 rows of the tile and the 2 bits are generated by taking a bit from each plane
            let tile_row_address = tile_address.wrapping_add(current_tile_row);
            let tile_first_plane = self.read_ppu_byte(tile_row_address);
            let tile_second_plane = self.read_ppu_byte(tile_row_address.wrapping_add(8));

            //TODO conmpute attribute table based on nametable address
            let attribute_table = 0x2000 + 0x3C0 as u16;

            //The attribute table divides the 960 tiles of nametable into 8x8 blocks of
            //4x4 tiles (each block contains 16 tiles). We can get the attribute table entry using
            // the nametable index:
            //
            // 111 111 -> the 3 MSBs are the 3 MSB of the tile index,
            // while the 3 LSBs are bit 2, 3 and 4 of the index

            let attribute_table_index =
                (nametable_index >> 7) << 3 | ((nametable_index & 0x1F) >> 2);

            let attribute_table_entry = self.read_ppu_byte(attribute_table + attribute_table_index);

            //Each byte in the attribute table is the 2 MSB for the palette for a 4x4 block inside
            //the 8x8 block
            let internal_group_index =
                ((nametable_index & 0x40) >> 5) | ((nametable_index & 0x2) >> 1);

            //The attribute table contains the MSB of the palette to use for this group
            let palette_msb = ((attribute_table_entry & 0x3) << (internal_group_index * 2))
                >> (internal_group_index * 2);

            for current_pixel in 0..=7 {
                let palette_lsb = Nes::get_tile_pixel_from_planes(
                    tile_first_plane,
                    tile_second_plane,
                    current_pixel,
                );

                let palette_index = (palette_msb << 2) | (palette_lsb as u8);

                //TODO must handle transparent background
                /*
                if palette_index == 0 {
                    continue;
                }*/
                // Nes palettes are 6 bit and the PPU only uses 6 bits to retrieve the value from
                // the system palette
                let palette_for_pixel =
                    self.read_ppu_byte(0x3F00 + u16::from(palette_index)) & 0x3F;

                let rgb_color = NES_PALETTE[palette_for_pixel as usize];

                let index_screen = (256 * current_scanline) + (i * 8) + current_pixel as u16;
                self.screen[index_screen as usize] = rgb_color;
            }
        }
    }

    fn get_sprite_size(&self) -> u16 {
        if self.ppuctrl.contains(PPUCTRL::SPRITE_SIZE_16) {
            16
        } else {
            8
        }
    }

    fn write_sprites(&mut self, current_scanline: u16) {
        // PPU has a 64 byte memory that works as a secondary OAM that contains
        // the 8 sprites for this line. We starts by doing a binary search

        let mut secondary_oam: [u8; 32] = [0; 32];
        let mut secondary_oam_index = 0;
        let sprite_size = self.get_sprite_size();

        for i in 0..=63 {
            // A sprite is composed by 4 bytes:
            // Byte 0 = y position - 1
            // Byte 1 = tile number
            // Byte 2 = Attributes
            // Byte 3 = x position

            let current_sprite_y_index = i * 4;
            let y_pos = (self.oam_ram[current_sprite_y_index] as u16).wrapping_add(1);

            if current_scanline >= y_pos && current_scanline < (y_pos + sprite_size) {
                if secondary_oam_index == 32 {
                    //There are more than 8 sprites on this line -> sprite overflow
                    self.ppustatus.insert(PPUSTATUS::SPRITE_OVERFLOW);
                } else {
                    secondary_oam[secondary_oam_index..=secondary_oam_index + 3].copy_from_slice(
                        &self.oam_ram[current_sprite_y_index..=current_sprite_y_index + 3],
                    );
                    secondary_oam_index += 4;
                }
            }
        }
        let number_sprites_scanline = secondary_oam_index / 4;
        //TODO handle sprite 0 hit
        //TODO handle sprite priority correctly
        for i in 0..number_sprites_scanline {
            let sprite_index = i * 4;
            let sprite_y_position = secondary_oam[sprite_index];
            let sprite_tile_index = secondary_oam[sprite_index + 1];
            let sprite_attributes = secondary_oam[sprite_index + 2];
            let sprite_x_position = secondary_oam[sprite_index + 3];

            //TODO NOT TRUE! The pattern table depends if 8x8 or 8x16 sprite!
            let pattern_table: u16 = if sprite_size == 8 {
                self.get_active_pattern_table(PPUCTRL::SPRITE_PATTERN_TABLE)
            } else {
                (u16::from(sprite_tile_index) & 0x1) * 0x1000
            };
            let tile_address = pattern_table.wrapping_add(u16::from(sprite_tile_index) << 4);

            //TODO NOT TRUE! Depends if I must draw the sprite flipped
            let current_tile_row = current_scanline
                .wrapping_sub(u16::from(sprite_y_position))
                .wrapping_sub(1);

            let tile_row_address = tile_address.wrapping_add(current_tile_row);
            let tile_first_plane = self.read_ppu_byte(tile_row_address);
            let tile_second_plane = self.read_ppu_byte(tile_row_address.wrapping_add(8));

            let palette_msb = sprite_attributes & 0x3;

            for current_pixel in 0..=7 {
                let pixel_to_render = if sprite_attributes & 0x40 == 0 {
                    current_pixel
                } else {
                    7 - current_pixel
                };

                let palette_lsb = Nes::get_tile_pixel_from_planes(
                    tile_first_plane,
                    tile_second_plane,
                    pixel_to_render,
                );

                if palette_lsb == 0x0 {
                    continue;
                }

                let palette_index = (palette_msb << 2) | (palette_lsb as u8);

                // Nes palettes are 6 bit and the PPU only uses 6 bits to retrieve the value from
                // the system palette
                let palette_for_pixel =
                    self.read_ppu_byte(0x3F10 + u16::from(palette_index)) & 0x3F;

                let rgb_color = NES_PALETTE[palette_for_pixel as usize];

                let index_screen =
                    (256 * current_scanline) + u16::from(sprite_x_position) + current_pixel as u16;
                self.screen[index_screen as usize] = rgb_color;
            }
        }
    }

    pub fn execute_ppu(&mut self, cpu_cycles: u32) {
        let ppu_cycles = cpu_cycles as i32 * 3;
        let clock_current_scanline = self.clock_current_scanline - ppu_cycles;

        self.clock_current_scanline = clock_current_scanline;
        if clock_current_scanline <= 0 {
            //new scanline!
            match self.current_scanline {
                0..=239 => {
                    if self.ppumask.contains(PPUMASK::BACKGROUND_ENABLED) {
                        self.write_background(self.current_scanline as u16);
                    }
                    if self.ppumask.contains(PPUMASK::SPRITES_ENABLED) {
                        self.write_sprites(self.current_scanline as u16);
                    }
                    self.current_scanline += 1
                }
                240 => {
                    //set HBlank, check if NMI is active and raise
                    let mut ppustatus = self.ppustatus;
                    ppustatus.insert(PPUSTATUS::V_BLANK);
                    self.ppustatus = ppustatus;

                    let ppuctrl = self.ppuctrl;
                    if ppuctrl.contains(PPUCTRL::NMI_ENABLED) {
                        self.raise_nmi();
                    }
                    self.current_scanline += 1;
                }
                //VBlank = do nothing
                241..=260 => {
                    self.current_scanline += 1;
                }
                //Finished scanlines, reset
                261 => {
                    self.current_scanline = 0;
                }
                _ => {
                    //TODO panic
                    panic!("Bad scanline")
                }
            }
            self.clock_current_scanline += 341;
        }
    }
}
